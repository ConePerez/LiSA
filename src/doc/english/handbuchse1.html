<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>What is LiSA? - Introduction and Overview</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html,5 --> 
<meta name="src" content="handbuch.tex"> 
<meta name="date" content="2010-08-13 17:57:00"> 
<link rel="stylesheet" type="text/css" href="handbuch.css"> 
</head><body 
>
<!--l. 101--><div class="crosslinks"><p class="noindent">[<a 
href="handbuchse2.html" >next</a>] [<a 
href="#tailhandbuchse1.html">tail</a>] [<a 
href="handbuchch1.html#handbuchse1.html" >up</a>] </p></div>
<h3 class="sectionHead"><span class="titlemark">1.1   </span> <a 
 id="x3-20001.1"></a>What is LiSA? - Introduction and Overview</h3>
<!--l. 9--><p class="noindent" >LiSA - A Library of Scheduling Algorithms is a software package for solving deterministic shop
scheduling problems. In a shop scheduling problem, a set of jobs has to be processed on
a set of machines with additional constraints such that a specific objective function
                                                                                         
                                                                                         
becomes optimal. All parameters are known and fixed. In the literature, such problems are
usually described by a triplet <span 
class="cmmi-12">&alpha;</span><span 
class="cmsy-10x-x-120">&#x2223;</span><span 
class="cmmi-12">&beta;</span><span 
class="cmsy-10x-x-120">&#x2223;</span><span 
class="cmmi-12">&gamma;</span>, where <span 
class="cmmi-12">&alpha; </span>denotes the machine environment, <span 
class="cmmi-12">&beta; </span>gives
additional constraints for the jobs and <span 
class="cmmi-12">&gamma; </span>describes the objective function. A feasible
solution of a shop problem is denoted as a sequence, and the corresponding starting (or
completion) times constitute a schedule. Sequences and schedules are described by matrices
and in LiSA also by acyclic digraphs and Gantt charts, respectively. Since most shop
problems are hard to solve, LiSA contains a number of constructive and iterative heuristics.
<br 
class="newline" />
<!--l. 21--><p class="noindent" >If a user wishes to solve a scheduling problem by means of LiSA, one has to fix the
problem type in the <span 
class="cmmi-12">&alpha;</span><span 
class="cmsy-10x-x-120">&#x2223;</span><span 
class="cmmi-12">&beta;</span><span 
class="cmsy-10x-x-120">&#x2223;</span><span 
class="cmmi-12">&gamma; </span>notation and the number of jobs and machines using the
graphical user interface. The processing times and the remaining input parameters can be
entered manually or generated randomly. It is also possible to read these data from an
XML file. When data input is completed, all algorithms that solve the problem either
exactly or approximately can be invoked. After the application of an algorithm, the
schedule will be visualized in a Gantt chart which can be job and machine oriented,
respectively. If a first solution is available, the iterative algorithms are released for use.
Since most algorithms offer a set of parameters, the user has a number of strategies
for solving his or her problems at hand. The solution can be stored in an XML file.
<br 
class="newline" />
<!--l. 30--><p class="noindent" >LiSA contains some extras, e.g. the check of the complexity status (with a reference) of a
problem. Here, the database on the complexity of scheduling problems, developed by the
colleagues from the University of Osnabrück, is used. In addition, manipulations of
Gantt charts are possible such that the user can influence the construction of a schedule.
<br 
class="newline" />
<!--l. 34--><p class="noindent" >LiSA has a modular structure in which every algorithm can also be used externally. So it is
possible to call an algorithm by a command line or to incorporate it into an automated call of
algorithms. When using such an automated call of algorithms, after fixing a problem type and the
parameters, one can solve a specific number of instances using all algorithms available for this type
of problems. For all of these instances, LiSA stores a list of solutions generated by the algorithms
which can be inspected via the graphical user interface. By means of the generated log file,
one can filter the results into a file compatible with Excel so that a quick evaluation is
possible. In addition, it is possible to construct hybrid algorithms using this concept.
<br 
class="newline" />
<!--l. 39--><p class="noindent" >By the modular structure it is easily possible for the user to incorporate own algorithms into LiSA.
In addition to the C++ source code, one needs an XML file which makes algorithm available to
the graphical user interface, so that LiSA can automatically check if it can be used for solving a
given problem. A help file for the new algorithm makes it possible for other users to understand its
parameter set and invoke it correctly.<br 
class="newline" />
<!--l. 43--><p class="noindent" >This handbook has the following structure:<br 
class="newline" />
<!--l. 45--><p class="noindent" >In addition to this introduction, Chapter 1 contains an overview of the LiSA team, the system
requirements for the use of LiSA and the license conditions.<br 
class="newline" />
<!--l. 48--><p class="noindent" >The notations used in LiSA, the classification of the problems, the used block matrices model with
the basic algorithms and an overview of the algorithms contained in LiSA are given in Chapter 2.
Here, we also describe the file format used in LiSA. <br 
class="newline" />
<!--l. 52--><p class="noindent" >The following three chapters describe the input of the problem (Chapter 3), the algorithms used in
LiSA (Chapter 4), partitioned into universally usable exact algorithms, universally usable
constructive and iterative heuristics, special algorithms and, finally, the output of the results
(Chapter 5).<br 
class="newline" />
<!--l. 58--><p class="noindent" >Chapter 6 contains some extras starting with the description of additional internal program
modules, e.g. the determination of the complexity status of a problem, the manipulation of a
schedule or reducibility algorithms.<br 
class="newline" />Moreover, the incorporation of own algorithms and the automated call of algorithms are described.
<br 
class="newline" />
<!--l. 63--><p class="noindent" >Chapter 8 contains some illustrative examples for using LiSA.<br 
class="newline" />
<!--l. 65--><p class="noindent" >The handbook finishes with an XML reference, the GNU license conditions and a literature
overview given in an appendix.
                                                                                         
                                                                                         
<!--l. 112--><div class="crosslinks"><p class="noindent">[<a 
href="handbuchse2.html" >next</a>] [<a 
href="handbuchse1.html" >front</a>] [<a 
href="handbuchch1.html#handbuchse1.html" >up</a>] </p></div>
<!--l. 112--><p class="noindent" ><a 
 id="tailhandbuchse1.html"></a>  
</body></html> 
