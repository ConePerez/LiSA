/*
 * ************** order.hpp *******************************
 * 
 * object for indirect sorting, mainly written for ordering matrix elements
 *
 * Owner: Thomas Tautenhahn
 *
 * 19.9.1998
*/

#ifndef _order_h
#define _order_h

#include "matrix.hpp"

/** @name Orders and Sorting
    The following methods of sorting are implemented in LiSA:\\
    
    - sort the elements of a list\\
    - generate a sorted index for elements of a vector or matrix\\

    Sorting a list is a function of Lisa_List<T> and Lisa_GenericList, 
    a sorted index is generated by Lisa_Order.
    @author Thomas Tautenhahn
    @version 2.3pre3
    @see Lisa_List 
    @see Lisa_GenericList    
*/
//@{
/** a class for indirect sorting.
    This class provides a sorted index for elements of a matrix or vector.
    It does not affect the elements sorted, so you can have several orders 
    for instance for the set of jobs. All sorting methods employed are 
    stable, you can sort with different keys consecutively. The keys must 
    provide a method to be casted to type float. 

    Include file LiSA/src/basics/order.h, it uses matrix.

    For sorting lists better use the corresponding list functions. 
    Lisa_GenericList can even sort keys which cannot be casted into float 
    values. 

    @author Thomas Tautenhahn
    @version 2.3pre3
    @see Lisa_Vector
    @see Lisa_Matrix 
    @see Lisa_GenericList
*/ 

class Lisa_Order
  {
    private: 
      Lisa_Vector<double> * key;
      Lisa_Vector<int> * index;
      int anz, m, n;
    public: 
      /// construct an index for a vector of n elements 
      Lisa_Order(int n);
      /// construct an index for a matrix of n x m elements
      Lisa_Order(int n, int m);
      ~Lisa_Order();    
      /// let order read the keys as a matrix (also for Lisa_Matrix<float>)
      void read(Lisa_Matrix<int>*);
      void read(Lisa_Matrix<float>*);
      void read(Lisa_Matrix<double>*);     
      /// give the keys on form of a vector (also for Lisa_vector<float>)
      void read(Lisa_Vector<int>*);    
      void read(Lisa_Vector<float>*);
      void read(Lisa_Vector<double>* ve){ (*key)=(*ve); }
      /// give the i-th key separately
      void read_one_key(int i, double k) { (*key)[i]=k; }
      /// give key at position (i,j) separately
      void read_one_key(int i, int j, double k) { (*key)[m*i+j]=k; } 
      /// get one-dimensional index, for example V[(*RF)[3]]
      int operator[](int h) { return (*index)[h]; }
      /// get two-dimensional index, for example M[RF->zei(3)][RF->spa(3)]
      int row(int h){ return (*index)[h]/m; }
      /// get corresponding column number
      int col(int h){ return (*index)[h]%m; }
      /** computing the order according to nondecreasing keys, this means 
          V[(*RF)[i]]<= V[(*RF)[i+1]] for all i, algorithm is stable 
          (elements with same key stay in previous order) so you can sort 
          with multiple keys */
      void sort();
      /** put elements with same key together, first element stays the same, 
          then all elements with same key, then next element not listed yet 
          from the original order and so on, algorithm is stable */
      void group();
  };
//@}      
#endif




